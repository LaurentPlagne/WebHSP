<!DOCTYPE html>
<html lang="en" data-theme="light">
<head>
    <meta charset="utf-t">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@picocss/pico@2/css/pico.min.css" />
    <title>Hydro Valley Visualizer & Computer</title>
    <script type="text/javascript" src="https://unpkg.com/vis-network/standalone/umd/vis-network.min.js"></script>
    <style>
        html, body { height: 100%; margin: 0; }
        body { display: flex; flex-direction: column; }
        main.container { flex-grow: 1; display: flex; flex-direction: column; }
        main.container > .grid { flex-grow: 1; grid-template-columns: 1fr 1.5fr; gap: var(--pico-spacing); }
        .grid > div, .grid > div > article { height: 100%; display: flex; flex-direction: column; }
        #network-graph { flex-grow: 1; border: 1px solid var(--pico-muted-border-color); }
        #json-input { flex-grow: 1; }
    </style>
</head>
<body>
    <header class="container">
        <hgroup>
            <h1>Hydro Valley Visualizer & Computer</h1>
            <h2>Define a hydro valley and run computations</h2>
        </hgroup>
        <nav>
            <ul>
                <li><button class="secondary" id="theme-switcher">Toggle Theme</button></li>
            </ul>
        </nav>
    </header>
    <main class="container">
        <div class="grid">
            <div>
                <article>
                    <hgroup>
                        <h2>Valley Definition (JSON)</h2>
                        <p>Edit the JSON below to see the graph update in real-time.</p>
                    </hgroup>
                    <textarea id="json-input" rows="25"></textarea>
                    <footer>
                        <button id="compute-btn">Run Simulation</button>
                    </footer>
                </article>
                <article>
                    <hgroup>
                        <h2>Computation Status</h2>
                    </hgroup>
                    <pre><code id="result-output">...</code></pre>
                </article>
            </div>
            <div>
                <article>
                    <hgroup>
                        <h2>Valley Network Graph</h2>
                    </hgroup>
                    <div id="network-graph"></div>
                </article>
            </div>
        </div>
    </main>
    <script>
        const jsonInput = document.getElementById('json-input');
        const computeBtn = document.getElementById('compute-btn');
        const resultOutput = document.getElementById('result-output');
        const networkContainer = document.getElementById('network-graph');
        const themeSwitcher = document.getElementById('theme-switcher');
        const htmlElement = document.documentElement;
        let network = null;

        const options = {
            layout: {
                hierarchical: {
                    enabled: true,
                    direction: 'UD',
                    sortMethod: 'directed',
                    levelSeparation: 120,
                    nodeSpacing: 150,
                }
            },
            physics: { enabled: false },
            edges: { arrows: 'to' }
        };

        function drawNetwork(valleyData) {
            try {
                const nodes = new vis.DataSet();
                const edges = new vis.DataSet();
                const nodeLevels = {};

                // --- Final, Correct Level Assignment Logic ---
                const turbineDownstream = new Set(valleyData.units.filter(u => u.type === 'turbine').map(u => u.downstream_reservoir));
                valleyData.reservoirs.forEach(r => {
                    if (!turbineDownstream.has(r.name)) {
                        nodeLevels[r.name] = 0;
                    }
                });

                const maxIterations = valleyData.reservoirs.length + valleyData.units.length;
                for (let i = 0; i < maxIterations; i++) {
                    valleyData.units.forEach(unit => {
                        const upLevel = nodeLevels[unit.upstream_reservoir];
                        if (upLevel !== undefined) {
                            // Set unit level
                            const newUnitLevel = upLevel + 1;
                            if (nodeLevels[unit.name] === undefined || newUnitLevel > nodeLevels[unit.name]) {
                                nodeLevels[unit.name] = newUnitLevel;
                            }
                            // Set downstream reservoir level
                            const newDownstreamLevel = newUnitLevel + 1;
                            if (nodeLevels[unit.downstream_reservoir] === undefined || newDownstreamLevel > nodeLevels[unit.downstream_reservoir]) {
                                nodeLevels[unit.downstream_reservoir] = newDownstreamLevel;
                            }
                        }
                    });
                }

                valleyData.reservoirs.forEach(r => {
                    nodes.add({ id: r.name, label: r.name, shape: 'triangleDown', color: '#1E90FF', level: nodeLevels[r.name] });
                });

                valleyData.units.forEach(u => {
                    nodes.add({
                        id: u.name, label: u.name, shape: 'dot', size: 20,
                        color: u.type === 'turbine' ? '#4CAF50' : '#F44336',
                        level: nodeLevels[u.name]
                    });

                    const isPump = u.type === 'pump';
                    const edgeOptions = {
                        smooth: { enabled: true, type: isPump ? 'curvedCCW' : 'curvedCW', roundness: 0.25 },
                    };

                    edges.add({ from: u.upstream_reservoir, to: u.name, ...edgeOptions });
                    edges.add({ from: u.name, to: u.downstream_reservoir, ...edgeOptions });
                });

                const data = { nodes, edges };
                if (network === null) {
                    network = new vis.Network(networkContainer, data, options);
                } else {
                    network.setData(data);
                }
            } catch (e) {
                console.error("Failed to draw network:", e);
                if (network) network.setData({ nodes: [], edges: [] });
            }
        }

        jsonInput.addEventListener('input', () => {
            try {
                const valleyData = JSON.parse(jsonInput.value);
                drawNetwork(valleyData);
            } catch (e) {
                if (network) network.setData({ nodes: [], edges: [] });
            }
        });

        computeBtn.addEventListener('click', async () => {
            resultOutput.textContent = 'Running simulation...';
            try {
                const valleyData = JSON.parse(jsonInput.value);
                const response = await fetch('/api/run_simulation', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(valleyData)
                });
                if (!response.ok) throw new Error(`Server error: ${response.statusText}`);
                const result = await response.json();
                sessionStorage.setItem('simulationResults', JSON.stringify(result));
                window.location.href = 'results.html';
            } catch (e) {
                resultOutput.textContent = `Error: ${e.message}`;
            }
        });

        function setTheme(theme) {
            htmlElement.setAttribute('data-theme', theme);
            localStorage.setItem('theme', theme);
        }
        themeSwitcher.addEventListener('click', () => {
            const newTheme = htmlElement.getAttribute('data-theme') === 'light' ? 'dark' : 'light';
            setTheme(newTheme);
        });

        async function loadInitialData() {
            try {
                const response = await fetch('/datasets/hydro_valley_instance.json');
                const initialData = await response.json();
                jsonInput.value = JSON.stringify(initialData, null, 2);
                drawNetwork(initialData);
            } catch (e) {
                jsonInput.value = `Error loading initial data: ${e.message}`;
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            const savedTheme = localStorage.getItem('theme') || 'light';
            setTheme(savedTheme);
            loadInitialData();
        });
    </script>
</body>
</html>
